/*
 * hi253 Camera Driver
 *
 * Copyright (C) 2008 Renesas Solutions Corp.
 * Kuninori Morimoto <morimoto.kuninori@renesas.com>
 *
 * Based on ov7670 and soc_camera_platform driver,
 *
 * Copyright 2006-7 Jonathan Corbet <corbet@lwn.net>
 * Copyright (C) 2008 Magnus Damm
 * Copyright (C) 2008, Guennadi Liakhovetski <kernel@pengutronix.de>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#include <linux/init.h>
#include <linux/module.h>
#include <linux/i2c.h>
#include <linux/slab.h>
#include <linux/delay.h>
#include <linux/videodev2.h>
#include <mach/gpio.h>
#include <media/v4l2-chip-ident.h>
#include <media/v4l2-subdev.h>
#include <media/soc_camera.h>

#include <media/hi253.h>

#define SENSOR_DEBUG
#ifdef SENSOR_DEBUG
#define SENDBG(stuff...) printk(KERN_DEBUG"SENSOR: " stuff)
#else
#define SENDBG(fmt, args...) do{}while(0)
#endif 


/* hi253 register address */
#define PWRCTL			0x01
#define PAGEMODE 		0x03
#define DEVID			0x04
#define PLLCTL1			0x0E
#define PLLCTL2			0x0F

/* hi253 register detail */

/* PAGEMODE */


/* PWRCTL PAGEMODE 0*/
#define SCCB_RESET 			0x02	/* Reset to default value */
#define SOFT_SLEEP_MODE 	0x01		/* Soft sleep mode */

#define SOFT_SLEEP_ON		0x01	
#define SOFT_SLEEP_OFF		0x00

/* PLLCTL */


/* PLLCTL2 */


/*
 * ID
 */
#define HI253_PID		0x92	 /* Product ID Number */


/*
 * struct
 */

struct hi253_color_format {
	const struct soc_camera_data_format *format;
};

struct hi253_win_size {
	char                     *name;
	__u32                     width;
	__u32                     height;
//	unsigned char             com7_bit;
	const struct regval_list *regs;
};

struct hi253_priv {
	struct v4l2_subdev                	subdev;
	struct hi253_camera_info        	*info;
	const struct hi253_color_format 	*fmt;
	const struct hi253_win_size     	*win;
	int                               		model;
};

#define ENDMARKER { 0xff, 0xff }


/*
 * register setting for initialize 
 */

u32 HI253_pv_HI253_exposure_lines = 0x0249f0;
u32 HI253_cp_HI253_exposure_lines = 0;



/**---------------------------------------------------------------------------*
 ** 						Local Variables 								 *
 **---------------------------------------------------------------------------*/

/*lint -save -e533 */
const struct regval_list hi253_sensor_yuv640X480[]=
{
	{0x03, 0x18},
	{0x10, 0x07},
	{0x11, 0x00},
	{0x12, 0x20},
	{0x20, 0x02},
	{0x21, 0x84}, //80},
	{0x22, 0x01},
	{0x23, 0xe0},
	{0x24, 0x00},
	{0x25, 0x04}, //00},
	{0x26, 0x00},
	{0x27, 0x00},
	{0x28, 0x02},
	{0x29, 0x84}, //80},
	{0x2a, 0x01},
	{0x2b, 0xe0},
	{0x2c, 0x14},
	{0x2d, 0x00},
	{0x2e, 0x14},
	{0x2f, 0x00},
	{0x30, 0x66},
	{0xff, 0xff},
};

const struct regval_list hi253_sensor_yuv1280X960[]=
{  
//{0x01, 0xf1}, //sleep off	
//{0x0e, 0x00}, //PLL off
//{0x03, 0x00},
//{0x10, 0x00},
//{0x11, 0x93}, //Windowing On, 1Frame Skip 93

{0x03, 0x18},
{0x10, 0x07},
{0x11, 0x00},
{0x12, 0x20},
{0x20, 0x05},
{0x21, 0x00},
{0x22, 0x03},
{0x23, 0xc0},
{0x24, 0x00},
{0x25, 0x04},
{0x26, 0x00},
{0x27, 0x04},
{0x28, 0x05},
{0x29, 0x04},
{0x2a, 0x03},
{0x2b, 0xc4},
{0x2c, 0x0a},
{0x2d, 0x00},
{0x2e, 0x0a},
{0x2f, 0x00},
{0x30, 0x41}, //41->44

//{0x03, 0x20},
//{0x10, 0x1c},
//{0x03, 0x22},
//{0x10, 0x6a},

//{0x03, 0x00}, //Sleep Off	
//{0x01, 0xc0}, // f8

{0xff, 0xff},
//{HI253_WRITE_DELAY,100}

};

const struct regval_list hi253_sensor_yuv352X288[] =
	{  
//	{0x01, 0x59}, //sleep on	
//	{0x0e, 0x03}, //PLL on
//	{0x0e, 0x73}, //PLLx2
//	{0x03, 0x00},
//	{0x10, 0x00},
//	{0x11, 0x93}, //Windowing On, 1Frame Skip 93
	
	{0x03, 0x18},
	{0x10, 0x07},
	{0x11, 0x00},
	{0x12, 0x20},
	
	{0x20, 0x01},   // 352
	{0x21, 0x60},
	{0x22, 0x01},  // 288
	{0x23, 0x20},
	
	{0x24, 0x00},
	{0x25, 0x04},
	{0x26, 0x00},
	{0x27, 0x04},
	
	{0x28, 0x01},
	{0x29, 0x64},
	{0x2a, 0x01},
	{0x2b, 0x24},
	
	{0x2c, 0x21},
	{0x2d, 0x55},
	{0x2e, 0x24},
	{0x2f, 0x5D},
	
	{0x30, 0x47}, //47

//	{0x03, 0x00}, //Sleep Off	
//	{0x01, 0x58}, // f8
	
	{0xff, 0xff},
	//{HI253_WRITE_DELAY,100}

};

const struct regval_list hi253_sensor_yuv800X600[]=
{
{0x01, 0xf1}, //sleep off	
{0x0e, 0x00}, //PLL off
{0x03, 0x00},
{0x10, 0x10},
{0x11, 0x93}, //Windowing On, 1Frame Skip 93

{0x03, 0x18},
{0x10, 0x00},
{0x11, 0x00},
{0x12, 0x20},

{0x03, 0x20},
{0x10, 0x1c},
{0x03, 0x22},
{0x10, 0x6a},

{0x03, 0x00}, //Sleep Off	
{0x01, 0xc0}, // f8

{0xff, 0xff},
//{HI253_WRITE_DELAY,100}

};

const struct regval_list hi253_sensor_yuv1600X1200[]=
{
//{0x01, 0xf1}, //sleep off	
//{0x0e, 0x00}, //PLL off
//{0x03, 0x00},
//{0x10, 0x00},
//{0x11, 0x90}, //Windowing On, 1Frame Skip 93

{0x03, 0x18},
{0x10, 0x00},
{0x11, 0x00},
{0x12, 0x20},

//{0x03, 0x20},
//{0x10, 0x1c},
//{0x03, 0x22},
//{0x10, 0x6a},

//{0x03, 0x00}, //Sleep Off	
//{0x01, 0xc0}, // f8

{0xff, 0xff},
//{HI253_WRITE_DELAY,100}

};


/******************************************************************************/
// Description: set brightness 
// Global resource dependence: 
// Author:
// Note:
//		level  must smaller than 8
/******************************************************************************/
 const struct regval_list HI253_brightness_tab[][7]=
{
{
{0x03,0x10}, //-3
{0x40,0xb0}, 
{0xff,0xff},
},
{
{0x03,0x10}, //-2
{0x40,0xa0}, 
{0xff,0xff},
},
{
{0x03,0x10}, //-1
{0x40,0x90}, 
{0xff,0xff},
},
{
{0x03,0x10}, //0
{0x40,0x00}, 
{0xff,0xff},
},
{
{0x03,0x10}, // 1
{0x40,0x10}, 
{0xff,0xff},
},
{
{0x03,0x10}, // 2
{0x40,0x20}, 
{0xff,0xff},
},
{
{0x03,0x10}, // +3
{0x40,0x30}, 
{0xff,0xff},
},

};

const struct regval_list HI253_YUV_640X480[]=
{
{0x01, 0x61}, //sleep on   //backup : 0x01, 0xf9
{0x08, 0x0f}, //Hi-Z on
{0x01, 0x60}, //sleep off

{0x03, 0x00}, // Dummy 750us START
{0x03, 0x00},
{0x03, 0x00},
{0x03, 0x00},
{0x03, 0x00},
{0x03, 0x00},
{0x03, 0x00},
{0x03, 0x00},
{0x03, 0x00},
{0x03, 0x00}, // Dummy 750us END

{0x0e, 0x03}, //PLL On
{0x0e, 0x73}, //PLLx2

{0x03, 0x00}, // Dummy 750us START
{0x03, 0x00},
{0x03, 0x00},
{0x03, 0x00},
{0x03, 0x00},
{0x03, 0x00},
{0x03, 0x00},
{0x03, 0x00},
{0x03, 0x00},
{0x03, 0x00}, // Dummy 750us END

{0x0e, 0x00}, //PLL off
{0x01, 0x51}, //sleep on
{0x08, 0x00}, //Hi-Z off
{0x01, 0xf3},
{0x01, 0xf1},

// PAGE 20
{0x03, 0x20}, //page 20
{0x10, 0x1c}, //ae off

// PAGE 22
{0x03, 0x22}, //page 22
{0x10, 0x69}, //awb off

//Initial Start
{0x03, 0x00},
{0x10, 0x00}, //Sub 1/2_Preview1 Mode, VSync Type2  00
{0x11, 0x90}, //Windowing On, 1Frame Skip, Not rata
{0x12, 0x04}, //rinsing edge  05
{0x0b, 0xaa}, //ESD Check Register
{0x0c, 0xaa}, //ESD Check Register
{0x0d, 0xaa}, //ESD Check Register
{0x20, 0x00}, //Windowing start point Y
{0x21, 0x04},
{0x22, 0x00}, //Windowing start point X
{0x23, 0x07},
{0x24, 0x04},
{0x25, 0xb0},
{0x26, 0x06},
{0x27, 0x40}, //WINROW END
{0x40, 0x01}, //Hblank 408
{0x41, 0x98}, 
{0x42, 0x00}, //Vblank 20
{0x43, 0x14},
{0x45, 0x04},
{0x46, 0x18},
{0x47, 0xd8},

//BLC
{0x80, 0x2e},
{0x81, 0x7e},
{0x82, 0x90},
{0x83, 0x00},
{0x84, 0x0c},
{0x85, 0x00},
{0x90, 0x0a}, //BLC_TIME_TH_ON
{0x91, 0x0a}, //BLC_TIME_TH_OFF 
{0x92, 0xd8}, //BLC_AG_TH_ON
{0x93, 0xd0}, //BLC_AG_TH_OFF
{0x94, 0x75},
{0x95, 0x70},
{0x96, 0xdc},
{0x97, 0xfe},
{0x98, 0x38},

//OutDoor  BLC
{0x99, 0x43},
{0x9a, 0x43},
{0x9b, 0x43},
{0x9c, 0x43},

//Dark BLC
{0xa0, 0x00},
{0xa2, 0x00},
{0xa4, 0x00},
{0xa6, 0x00},

//Normal BLC
{0xa8, 0x43},
{0xaa, 0x43},
{0xac, 0x43},
{0xae, 0x43},


/////// PAGE 2 START ///////
{0x03, 0x02},
{0x12, 0x03},
{0x13, 0x03},
{0x16, 0x00},
{0x17, 0x8C},
{0x18, 0x4c}, //Double_AG off
{0x19, 0x00},
{0x1a, 0x39}, //ADC400->560
{0x1c, 0x09},
{0x1d, 0x40},
{0x1e, 0x30},
{0x1f, 0x10},

{0x20, 0x77},
{0x21, 0xde},
{0x22, 0xa7},
{0x23, 0x30}, //CLAMP
{0x27, 0x3c},
{0x2b, 0x80},
{0x2e, 0x11},
{0x2f, 0xa1},
{0x30, 0x05}, //For Hi-253 never no change 0x05

{0x50, 0x20},
{0x52, 0x01},
{0x55, 0x1c},
{0x56, 0x11},
{0x5d, 0xa2},
{0x5e, 0x5a},

{0x60, 0x87},
{0x61, 0x99},
{0x62, 0x88},
{0x63, 0x97},
{0x64, 0x88},
{0x65, 0x97},

{0x67, 0x0c},
{0x68, 0x0c},
{0x69, 0x0c},

{0x72, 0x89},
{0x73, 0x96},
{0x74, 0x89},
{0x75, 0x96},
{0x76, 0x89},
{0x77, 0x96},

{0x7c, 0x85},
{0x7d, 0xaf},
{0x80, 0x01},
{0x81, 0x7f},
{0x82, 0x13},

{0x83, 0x24},
{0x84, 0x7d},
{0x85, 0x81},
{0x86, 0x7d},
{0x87, 0x81},

{0x92, 0x48},
{0x93, 0x54},
{0x94, 0x7d},
{0x95, 0x81},
{0x96, 0x7d},
{0x97, 0x81},

{0xa0, 0x02},
{0xa1, 0x7b},
{0xa2, 0x02},
{0xa3, 0x7b},
{0xa4, 0x7b},
{0xa5, 0x02},
{0xa6, 0x7b},
{0xa7, 0x02},

{0xa8, 0x85},
{0xa9, 0x8c},
{0xaa, 0x85},
{0xab, 0x8c},
{0xac, 0x10},
{0xad, 0x16},
{0xae, 0x10},
{0xaf, 0x16},

{0xb0, 0x99},
{0xb1, 0xa3},
{0xb2, 0xa4},
{0xb3, 0xae},
{0xb4, 0x9b},
{0xb5, 0xa2},
{0xb6, 0xa6},
{0xb7, 0xac},
{0xb8, 0x9b},
{0xb9, 0x9f},
{0xba, 0xa6},
{0xbb, 0xaa},
{0xbc, 0x9b},
{0xbd, 0x9f},
{0xbe, 0xa6},
{0xbf, 0xaa},

{0xc4, 0x2c},
{0xc5, 0x43},
{0xc6, 0x63},
{0xc7, 0x79},

{0xc8, 0x2d},
{0xc9, 0x42},
{0xca, 0x2d},
{0xcb, 0x42},
{0xcc, 0x64},
{0xcd, 0x78},
{0xce, 0x64},
{0xcf, 0x78},

{0xd0, 0x0a},
{0xd1, 0x09},
{0xd4, 0x0a}, //DCDC_TIME_TH_ON
{0xd5, 0x0a}, //DCDC_TIME_TH_OFF 
{0xd6, 0xd8}, //DCDC_AG_TH_ON
{0xd7, 0xd0}, //DCDC_AG_TH_OFF
{0xe0, 0xc4},
{0xe1, 0xc4},
{0xe2, 0xc4},
{0xe3, 0xc4},
{0xe4, 0x00},
{0xe8, 0x80},
{0xe9, 0x40},
{0xea, 0x7f},

/////// PAGE 3 ///////
{0x03, 0x03},
{0x10, 0x10},

/////// PAGE 10 START ///////
{0x03, 0x10},
{0x10, 0x01}, // CrYCbY // For Demoset 0x03
{0x12, 0x30},
{0x20, 0x00},

{0x30, 0x00},
{0x31, 0x00},
{0x32, 0x00},
{0x33, 0x00},

{0x34, 0x30},
{0x35, 0x00},
{0x36, 0x00},
{0x38, 0x00},
{0x3e, 0x58},
{0x3f, 0x00},

{0x40, 0x80}, // YOFS
{0x41, 0x00}, // DYOFS

{0x60, 0x67},
{0x61, 0x7c}, //7e //8e //88 //80
{0x62, 0x7c}, //7e //8e //88 //80
{0x63, 0x50}, //Double_AG 50->30
{0x64, 0x41},

{0x66, 0x42},
{0x67, 0x20},

{0x6a, 0x80}, //8a
{0x6b, 0x84}, //74
{0x6c, 0x80}, //7e //7a
{0x6d, 0x80}, //8e

//Don't touch//////////////////////////
//{0x72, 0x84},
//{0x76, 0x19},
//{0x73, 0x70},
//{0x74, 0x68},
//{0x75, 0x60}, // white protection ON
//{0x77, 0x0e}, //08 //0a
//{0x78, 0x2a}, //20
//{0x79, 0x08},
////////////////////////////////////////

/////// PAGE 11 START ///////
{0x03, 0x11},
{0x10, 0x7f},
{0x11, 0x40},
{0x12, 0x0a}, // Blue Max-Filter Delete
{0x13, 0xbb},

{0x26, 0x31}, // Double_AG 31->20
{0x27, 0x34}, // Double_AG 34->22
{0x28, 0x0f},
{0x29, 0x10},
{0x2b, 0x30},
{0x2c, 0x32},

//Out2 D-LPF th
{0x30, 0x70},
{0x31, 0x10},
{0x32, 0x58},
{0x33, 0x09},
{0x34, 0x06},
{0x35, 0x03},

//Out1 D-LPF th
{0x36, 0x70},
{0x37, 0x18},
{0x38, 0x58},
{0x39, 0x09},
{0x3a, 0x06},
{0x3b, 0x03},

//Indoor D-LPF th
{0x3c, 0x80},
{0x3d, 0x18},
{0x3e, 0xa0}, //80
{0x3f, 0x0c},
{0x40, 0x09},
{0x41, 0x06},

{0x42, 0x80},
{0x43, 0x18},
{0x44, 0xa0}, //80
{0x45, 0x12},
{0x46, 0x10},
{0x47, 0x10},

{0x48, 0x90},
{0x49, 0x40},
{0x4a, 0x80},
{0x4b, 0x13},
{0x4c, 0x10},
{0x4d, 0x11},

{0x4e, 0x80},
{0x4f, 0x30},
{0x50, 0x80},
{0x51, 0x13},
{0x52, 0x10},
{0x53, 0x13},

{0x54, 0x11},
{0x55, 0x17},
{0x56, 0x20},
{0x57, 0x01},
{0x58, 0x00},
{0x59, 0x00},

{0x5a, 0x1f}, //18
{0x5b, 0x00},
{0x5c, 0x00},

{0x60, 0x3f},
{0x62, 0x60},
{0x70, 0x06},

/////// PAGE 12 START ///////
{0x03, 0x12},
{0x20, 0x0f},
{0x21, 0x0f},

{0x25, 0x00}, //0x30

{0x28, 0x00},
{0x29, 0x00},
{0x2a, 0x00},

{0x30, 0x50},
{0x31, 0x18},
{0x32, 0x32},
{0x33, 0x40},
{0x34, 0x50},
{0x35, 0x70},
{0x36, 0xa0},

//Out2 th
{0x40, 0xa0},
{0x41, 0x40},
{0x42, 0xa0},
{0x43, 0x90},
{0x44, 0x90},
{0x45, 0x80},

//Out1 th
{0x46, 0xb0},
{0x47, 0x55},
{0x48, 0xa0},
{0x49, 0x90},
{0x4a, 0x90},
{0x4b, 0x80},

//Indoor th
{0x4c, 0xb0},
{0x4d, 0x40},
{0x4e, 0x90},
{0x4f, 0x90},
{0x50, 0xa0},
{0x51, 0x80},

//Dark1 th
{0x52, 0xb0},
{0x53, 0x60},
{0x54, 0xc0},
{0x55, 0xc0},
{0x56, 0xc0},
{0x57, 0x80},

//Dark2 th
{0x58, 0x90},
{0x59, 0x40},
{0x5a, 0xd0},
{0x5b, 0xd0},
{0x5c, 0xe0},
{0x5d, 0x80},

//Dark3 th
{0x5e, 0x88},
{0x5f, 0x40},
{0x60, 0xe0},
{0x61, 0xe0},
{0x62, 0xe0},
{0x63, 0x80},

{0x70, 0x15},
{0x71, 0x01}, //Don't Touch register

{0x72, 0x18},
{0x73, 0x01}, //Don't Touch register

{0x74, 0x25},
{0x75, 0x15},

{0x80, 0x20},
{0x81, 0x40},
{0x82, 0x65},
{0x85, 0x1a},
{0x88, 0x00},
{0x89, 0x00},
{0x90, 0x5d}, //For Preview

//Dont Touch register
{0xD0, 0x0c},
{0xD1, 0x80},
{0xD2, 0x67},
{0xD3, 0x00},
{0xD4, 0x00},
{0xD5, 0x02},
{0xD6, 0xff},
{0xD7, 0x18},
//End
{0x3b, 0x06},
{0x3c, 0x06},

{0xc5, 0x00},//55->48
{0xc6, 0x00},//48->40

/////// PAGE 13 START ///////
{0x03, 0x13},
//Edge
{0x10, 0xcb},
{0x11, 0x7b},
{0x12, 0x07},
{0x14, 0x00},

{0x20, 0x15},
{0x21, 0x13},
{0x22, 0x33},
{0x23, 0x05},
{0x24, 0x09},

{0x25, 0x0a},

{0x26, 0x18},
{0x27, 0x30},
{0x29, 0x12},
{0x2a, 0x50},

//Low clip th
{0x2b, 0x02},
{0x2c, 0x02},
{0x25, 0x06},
{0x2d, 0x0c},
{0x2e, 0x12},
{0x2f, 0x12},

//Out2 Edge
{0x50, 0x10},
{0x51, 0x14},
{0x52, 0x12},
{0x53, 0x0c},
{0x54, 0x0f},
{0x55, 0x0c},

//Out1 Edge
{0x56, 0x10},
{0x57, 0x13},
{0x58, 0x12},
{0x59, 0x0c},
{0x5a, 0x0f},
{0x5b, 0x0c},

//Indoor Edge
{0x5c, 0x0a},
{0x5d, 0x0b},
{0x5e, 0x0a},
{0x5f, 0x08},
{0x60, 0x09},
{0x61, 0x08},

//Dark1 Edge
{0x62, 0x08},
{0x63, 0x08},
{0x64, 0x08},
{0x65, 0x06},
{0x66, 0x06},
{0x67, 0x06},

//Dark2 Edge
{0x68, 0x07},
{0x69, 0x07},
{0x6a, 0x07},
{0x6b, 0x05},
{0x6c, 0x05},
{0x6d, 0x05},

//Dark3 Edge
{0x6e, 0x07},
{0x6f, 0x07},
{0x70, 0x07},
{0x71, 0x05},
{0x72, 0x05},
{0x73, 0x05},

//2DY
{0x80, 0xfd},
{0x81, 0x1f},
{0x82, 0x05},
{0x83, 0x31},

{0x90, 0x05},
{0x91, 0x05},
{0x92, 0x33},
{0x93, 0x30},
{0x94, 0x03},
{0x95, 0x14},
{0x97, 0x20},
{0x99, 0x20},

{0xa0, 0x01},
{0xa1, 0x02},
{0xa2, 0x01},
{0xa3, 0x02},
{0xa4, 0x05},
{0xa5, 0x05},
{0xa6, 0x07},
{0xa7, 0x08},
{0xa8, 0x07},
{0xa9, 0x08},
{0xaa, 0x07},
{0xab, 0x08},

//Out2 
{0xb0, 0x22},
{0xb1, 0x2a},
{0xb2, 0x28},
{0xb3, 0x22},
{0xb4, 0x2a},
{0xb5, 0x28},

//Out1 
{0xb6, 0x22},
{0xb7, 0x2a},
{0xb8, 0x28},
{0xb9, 0x22},
{0xba, 0x2a},
{0xbb, 0x28},

//Indoor 
{0xbc, 0x25},
{0xbd, 0x2a},
{0xbe, 0x27},
{0xbf, 0x25},
{0xc0, 0x2a},
{0xc1, 0x27},

//Dark1
{0xc2, 0x1e},
{0xc3, 0x24},
{0xc4, 0x20},
{0xc5, 0x1e},
{0xc6, 0x24},
{0xc7, 0x20},

//Dark2
{0xc8, 0x18},
{0xc9, 0x20},
{0xca, 0x1e},
{0xcb, 0x18},
{0xcc, 0x20},
{0xcd, 0x1e},

//Dark3 
{0xce, 0x18},
{0xcf, 0x20},
{0xd0, 0x1e},
{0xd1, 0x18},
{0xd2, 0x20},
{0xd3, 0x1e},

/////// PAGE 14 START ///////
{0x03, 0x14},
{0x10, 0x11},

{0x14, 0x80}, // GX
{0x15, 0x80}, // GY
{0x16, 0x80}, // RX
{0x17, 0x80}, // RY
{0x18, 0x80}, // BX
{0x19, 0x80}, // BY

{0x20, 0x60}, //X 60 //a0
{0x21, 0x80}, //Y

{0x22, 0x80},
{0x23, 0x80},
{0x24, 0x80},

{0x30, 0xc8},
{0x31, 0x2b},
{0x32, 0x00},
{0x33, 0x00},
{0x34, 0x90},

{0x40, 0x48}, //31
{0x50, 0x34}, //23 //32
{0x60, 0x29}, //1a //27
{0x70, 0x34}, //23 //32

/////// PAGE 15 START ///////
{0x03, 0x15},
{0x10, 0x0f},

//Rstep H 16
//Rstep L 14
{0x14, 0x42}, //CMCOFSGH_Day //4c
{0x15, 0x32}, //CMCOFSGM_CWF //3c
{0x16, 0x24}, //CMCOFSGL_A //2e
{0x17, 0x2f}, //CMC SIGN

//CMC_Default_CWF
{0x30, 0x8f},
{0x31, 0x59},
{0x32, 0x0a},
{0x33, 0x15},
{0x34, 0x5b},
{0x35, 0x06},
{0x36, 0x07},
{0x37, 0x40},
{0x38, 0x87}, //86

//CMC OFS L_A
{0x40, 0x92},
{0x41, 0x1b},
{0x42, 0x89},
{0x43, 0x81},
{0x44, 0x00},
{0x45, 0x01},
{0x46, 0x89},
{0x47, 0x9e},
{0x48, 0x28},

//{0x40, 0x93},
//{0x41, 0x1c},
//{0x42, 0x89},
//{0x43, 0x82},
//{0x44, 0x01},
//{0x45, 0x01},
//{0x46, 0x8a},
//{0x47, 0x9d},
//{0x48, 0x28},

//CMC POFS H_DAY
{0x50, 0x02},
{0x51, 0x82},
{0x52, 0x00},
{0x53, 0x07},
{0x54, 0x11},
{0x55, 0x98},
{0x56, 0x00},
{0x57, 0x0b},
{0x58, 0x8b},

{0x80, 0x03},
{0x85, 0x40},
{0x87, 0x02},
{0x88, 0x00},
{0x89, 0x00},
{0x8a, 0x00},

/////// PAGE 16 START ///////
{0x03, 0x16},
{0x10, 0x31},
{0x18, 0x5e},// Double_AG 5e->37
{0x19, 0x5d},// Double_AG 5e->36
{0x1a, 0x0e},
{0x1b, 0x01},
{0x1c, 0xdc},
{0x1d, 0xfe},

//GMA Default
{0x30, 0x00},
{0x31, 0x0a},
{0x32, 0x1f},
{0x33, 0x33},
{0x34, 0x53},
{0x35, 0x6c},
{0x36, 0x81},
{0x37, 0x94},
{0x38, 0xa4},
{0x39, 0xb3},
{0x3a, 0xc0},
{0x3b, 0xcb},
{0x3c, 0xd5},
{0x3d, 0xde},
{0x3e, 0xe6},
{0x3f, 0xee},
{0x40, 0xf5},
{0x41, 0xfc},
{0x42, 0xff},

{0x50, 0x00},
{0x51, 0x09},
{0x52, 0x1f},
{0x53, 0x37},
{0x54, 0x5b},
{0x55, 0x76},
{0x56, 0x8d},
{0x57, 0xa1},
{0x58, 0xb2},
{0x59, 0xbe},
{0x5a, 0xc9},
{0x5b, 0xd2},
{0x5c, 0xdb},
{0x5d, 0xe3},
{0x5e, 0xeb},
{0x5f, 0xf0},
{0x60, 0xf5},
{0x61, 0xf7},
{0x62, 0xf8},

{0x70, 0x00},
{0x71, 0x08},
{0x72, 0x17},
{0x73, 0x2f},
{0x74, 0x53},
{0x75, 0x6c},
{0x76, 0x81},
{0x77, 0x94},
{0x78, 0xa4},
{0x79, 0xb3},
{0x7a, 0xc0},
{0x7b, 0xcb},
{0x7c, 0xd5},
{0x7d, 0xde},
{0x7e, 0xe6},
{0x7f, 0xee},
{0x80, 0xf4},
{0x81, 0xfa},
{0x82, 0xff},

/////// PAGE 17 START ///////
{0x03, 0x17},
{0x10, 0xf7},

/////// PAGE 20 START ///////
//AE Start
{0x03, 0x20},
{0x11, 0x1c},
{0x18, 0x30},
{0x1a, 0x08},
{0x20, 0x01}, //05_lowtemp Y Mean off
{0x21, 0x30},
{0x22, 0x10},
{0x23, 0x00},
{0x24, 0x00}, //Uniform Scene Off

{0x28, 0xe7},
{0x29, 0x0d}, //20100305 ad->0d

// MTK set up 		anti banding --> 1/100 s
{0x2a, 0xff},
{0x2b, 0x04}, //f4->Adaptive off

{0x2c, 0xc2},
{0x2d, 0xcf},  //ff->AE Speed option
{0x2e, 0x33},
{0x30, 0x78}, //f8
{0x32, 0x03},
{0x33, 0x2e},
{0x34, 0x30},
{0x35, 0xd4},
{0x36, 0xfe},
{0x37, 0x32},
{0x38, 0x04},

{0x39, 0x22}, //AE_escapeC10
{0x3a, 0xde}, //AE_escapeC11

{0x3b, 0x22}, //AE_escapeC1
{0x3c, 0xde}, //AE_escapeC2
//Y_Frame TH
{0x50, 0x45},
{0x51, 0x88},

{0x56, 0x03},
{0x57, 0xf7},
{0x58, 0x14},
{0x59, 0x88},
{0x5a, 0x04},

//New Weight For Samsung
//{0x60, 0xaa},
//{0x61, 0xaa},
//{0x62, 0xaa},
//{0x63, 0xaa},
//{0x64, 0xaa},
//{0x65, 0xaa},
//{0x66, 0xab},
//{0x67, 0xEa},
//{0x68, 0xab},
//{0x69, 0xEa},
//{0x6a, 0xaa},
//{0x6b, 0xaa},
//{0x6c, 0xaa},
//{0x6d, 0xaa},
//{0x6e, 0xaa},
//{0x6f, 0xaa},

{0x60, 0x55}, // AEWGT1
{0x61, 0x55}, // AEWGT2
{0x62, 0x6a}, // AEWGT3
{0x63, 0xa9}, // AEWGT4
{0x64, 0x6a}, // AEWGT5
{0x65, 0xa9}, // AEWGT6
{0x66, 0x6a}, // AEWGT7
{0x67, 0xa9}, // AEWGT8
{0x68, 0x6b}, // AEWGT9
{0x69, 0xe9}, // AEWGT10
{0x6a, 0x6a}, // AEWGT11
{0x6b, 0xa9}, // AEWGT12
{0x6c, 0x6a}, // AEWGT13
{0x6d, 0xa9}, // AEWGT14
{0x6e, 0x55}, // AEWGT15
{0x6f, 0x55}, // AEWGT16

{0x70, 0x76}, //6e
{0x71, 0x00}, //82(+8)->+0

// haunting control
{0x76, 0x43},
{0x77, 0xe2}, //04
{0x78, 0x23}, //Yth1
{0x79, 0x42}, //Yth2
{0x7a, 0x23}, //23
{0x7b, 0x22}, //22
{0x7d, 0x23},

{0x83, 0x01}, //EXP Normal 33.33 fps 
{0x84, 0x5f}, 
{0x85, 0x00}, 

{0x86, 0x02}, //EXPMin 5859.38 fps
{0x87, 0x00}, 

{0x88, 0x04}, //EXP Max 10.00 fps 
{0x89, 0x92}, 
{0x8a, 0x00}, 

{0x8B, 0x75}, //EXP100 
{0x8C, 0x00}, 
{0x8D, 0x61}, //EXP120 
{0x8E, 0x00}, 

{0x9c, 0x18}, //EXP Limit 488.28 fps 
{0x9d, 0x00}, 
{0x9e, 0x02}, //EXP Unit 
{0x9f, 0x00}, 

//AE_Middle Time option
//{0xa0, 0x03},
//{0xa1, 0xa9},
//{0xa2, 0x80},

{0xb0, 0x18},
{0xb1, 0x14}, //ADC 400->560
{0xb2, 0xe0}, //d0
{0xb3, 0x18},
{0xb4, 0x1a},
{0xb5, 0x44},
{0xb6, 0x2f},
{0xb7, 0x28},
{0xb8, 0x25},
{0xb9, 0x22},
{0xba, 0x21},
{0xbb, 0x20},
{0xbc, 0x1f},
{0xbd, 0x1f},

//AE_Adaptive Time option
//{0xc0, 0x10},
//{0xc1, 0x2b},
//{0xc2, 0x2b},
//{0xc3, 0x2b},
//{0xc4, 0x08},

{0xc8, 0x80},
{0xc9, 0x40},

/////// PAGE 22 START ///////
{0x03, 0x22},
{0x10, 0xfd},
{0x11, 0x2e},
{0x19, 0x01}, // Low On //
{0x20, 0x30},
{0x21, 0x80},
{0x24, 0x01},
//{0x25, 0x00}, //7f New Lock Cond & New light stable

{0x30, 0x80},
{0x31, 0x80},
{0x38, 0x11},
{0x39, 0x34},

{0x40, 0xf4},
{0x41, 0x55}, //44
{0x42, 0x33}, //43

{0x43, 0xf6},
{0x44, 0x55}, //44
{0x45, 0x44}, //33
{0x46, 0x00},

//MTK set up 
{0x47, 0x94},

{0x50, 0xb2},
{0x51, 0x81},
{0x52, 0x98},

{0x80, 0x40}, //3e
{0x81, 0x20},
{0x82, 0x3e},

{0x83, 0x5e}, //5e
{0x84, 0x1e}, //24
{0x85, 0x5e}, //54 //56 //5a
{0x86, 0x22}, //24 //22

{0x87, 0x49},
{0x88, 0x39},
{0x89, 0x37}, //38
{0x8a, 0x28}, //2a

{0x8b, 0x41}, //47
{0x8c, 0x39}, 
{0x8d, 0x34}, 
{0x8e, 0x28}, //2c

{0x8f, 0x53}, //4e
{0x90, 0x52}, //4d
{0x91, 0x51}, //4c
{0x92, 0x4e}, //4a
{0x93, 0x4a}, //46
{0x94, 0x45},
{0x95, 0x3d},
{0x96, 0x31},
{0x97, 0x28},
{0x98, 0x24},
{0x99, 0x20},
{0x9a, 0x20},

{0x9b, 0x77},
{0x9c, 0x77},
{0x9d, 0x48},
{0x9e, 0x38},
{0x9f, 0x30},

{0xa0, 0x60},
{0xa1, 0x34},
{0xa2, 0x6f},
{0xa3, 0xff},

{0xa4, 0x14}, //1500fps
{0xa5, 0x2c}, // 700fps
{0xa6, 0xcf},

{0xad, 0x40},
{0xae, 0x4a},

{0xaf, 0x28},  // low temp Rgain
{0xb0, 0x26},  // low temp Rgain

{0xb1, 0x00}, //0x20 -> 0x00 0405 modify
{0xb4, 0xea},
{0xb8, 0xa0}, //a2: b-2, R+2  //b4 B-3, R+4 lowtemp
{0xb9, 0x00},

/////// PAGE 20 ///////
{0x03, 0x20},
{0x10, 0x8c},

// PAGE 20
{0x03, 0x20}, //page 20
{0x10, 0x9c}, //ae off

// PAGE 22
{0x03, 0x22}, //page 22
{0x10, 0xe9}, //awb off

// PAGE 0
{0x03, 0x00},
{0x0e, 0x03}, //PLL On
{0x0e, 0x73}, //PLLx2

{0x03, 0x00}, // Dummy 750us
{0x03, 0x00},
{0x03, 0x00},
{0x03, 0x00},
{0x03, 0x00},
{0x03, 0x00},
{0x03, 0x00},
{0x03, 0x00},
{0x03, 0x00},
{0x03, 0x00},

{0x03, 0x00}, // Page 0
{0x01, 0x60}, // Sleep Off

{0x03, 0x18},
{0x10, 0x07},
{0x11, 0x00},
{0x12, 0x20},
{0x20, 0x02},
{0x21, 0x84}, //80},
{0x22, 0x01},
{0x23, 0xe0},
{0x24, 0x00},
{0x25, 0x04}, //00},
{0x26, 0x00},
{0x27, 0x00},
{0x28, 0x02},
{0x29, 0x84}, //80},
{0x2a, 0x01},
{0x2b, 0xe0},
{0x2c, 0x14},
{0x2d, 0x00},
{0x2e, 0x14},
{0x2f, 0x00},
{0x30, 0x66},

{0x03, 0x22},	//CAM_WB_AUTO		
{0x11, 0x2e},				
{0x83, 0x5e},
{0x84, 0x1e},
{0x85, 0x5e},
{0x86, 0x22},


{0xff, 0xff},
//{HI253_WRITE_DELAY,1}
};

const struct regval_list HI253_wb_tab[6][9]=
{
{
{0x03, 0x22},	//CAM_WB_AUTO		
{0x11, 0x2e},				
{0x83, 0x5e},
{0x84, 0x1e},
{0x85, 0x5e},
{0x86, 0x22},
{0xff, 0xff},
{0xff, 0xff},
{0xff, 0xff}
},
	
{
{0x03, 0x22}, //CAM_WB_CLOUD
{0x11, 0x28},
{0x80, 0x71},
{0x82, 0x2b},
{0x83, 0x72},
{0x84, 0x70},
{0x85, 0x2b},
{0x86, 0x28},
{0xff, 0xff}
},

{
{0x03, 0x22}, //CAM_WB_DAYLIGHT
{0x11, 0x28},		  
{0x80, 0x59},
{0x82, 0x29},
{0x83, 0x60},
{0x84, 0x50},
{0x85, 0x2f},
{0x86, 0x23},
{0xff, 0xff}
},

{
{0x03, 0x22}, //CAM_WB_INCANDESCENCE
{0x11, 0x28},		  
{0x80, 0x29},
{0x82, 0x54},
{0x83, 0x2e},
{0x84, 0x23},
{0x85, 0x58},
{0x86, 0x4f},
{0xff, 0xff}
},

{
{0x03, 0x22}, //CAM_WB_TUNGSTEN
{0x80, 0x24},
{0x81, 0x20},
{0x82, 0x58},
{0x83, 0x27},
{0x84, 0x22},
{0x85, 0x58},
{0x86, 0x52},
{0xff, 0xff}
},

{
{0x03, 0x22}, //CAM_WB_FLUORESCENT
{0x11, 0x28},
{0x80, 0x41},
{0x82, 0x42},
{0x83, 0x44},
{0x84, 0x34},
{0x85, 0x46},
{0x86, 0x3a},
{0xff, 0xff}
}
};

/* for effect */
const struct regval_list HI253_effect_tab[6][8]=
{
{
{0x03, 0x10}, //CAM_EFFECT_ENC_NORMAL:
{0x11, 0x03},
{0x12, 0x30},
{0x13, 0x02},
{0x44, 0x80},
{0x45, 0x80},
{0xff, 0xff},
{0xff, 0xff}
},

{
{0x03, 0x10}, //C  AM_EFFECT_ENC_SEPIA
{0x11, 0x03},
{0x12, 0x33},
{0x13, 0x02},
{0x44, 0x70},
{0x45, 0x98},
{0xff, 0xff},
{0xff, 0xff}
},

{
{0x03, 0x10}, //CAM_EFFECT_ENC_SEPIAGREEN
{0x11, 0x03},
{0x12, 0x03},
{0x13, 0x02},
{0x40, 0x00},
{0x44, 0x30},
{0x45, 0x50},
{0xff, 0xff}
},


{
{0x03, 0x10}, //CAM_EFFECT_ENC_GRAYSCALE
{0x11, 0x03},
{0x12, 0x03},
{0x13, 0x02},
{0x40, 0x00},
{0x44, 0x80},
{0x45, 0x80},
{0xff, 0xff}
},

{
{0x03, 0x10}, //CAM_EFFECT_ENC_COLORINV
{0x11, 0x03},
{0x12, 0x08},
{0x13, 0x02},
{0x14, 0x00},
{0xff, 0xff},
{0xff, 0xff},
{0xff, 0xff}
},

{
{0x03, 0x10}, //CAM_EFFECT_ENC_SEPIABLUE
{0x11, 0x03},
{0x12, 0x03},
{0x40, 0x00},
{0x13, 0x02},
{0x44, 0xb0},
{0x45, 0x40},
{0xff, 0xff}
},

};


/*
 * register setting for window size
 */
	
static const struct regval_list hi253_uxga_regs[] = {
	{ 0x03, 0x00 },
	{ 0x20, 0x00 },
	{ 0x21, 0x0a },
	{ 0x22, 0x00 },
	{ 0x23, 0x0a },
		
	{ 0x40, 0x01 },
	{ 0x41, 0x68 },
	{ 0x42, 0x00 },
	{ 0x43, 0x14 },
	
	{ 0x03, 0x10 }, 	//page10
	{ 0x3f, 0x00 },
	{ 0x03, 0x12 },
	{ 0x20, 0x0f },
	{ 0x21, 0x0f }, 			
	{ 0x90, 0x5d },
		
	{ 0x03, 0x13 },
	{ 0x80, 0xfd }, 	
		
	{ 0x03, 0x00 }, //select uxga
	{ 0x10, 0x00 },
	ENDMARKER,
};

static const struct regval_list hi253_sxga_regs[] = {
	{ 0x03, 0x00 },
	{ 0x20, 0x00 },
	{ 0x21, 0x04 },  //uxga 0x0a
	{ 0x22, 0x00 },
	{ 0x23, 0x07 },  //uxga 0x0a
	
	{ 0x40, 0x01 },
	{ 0x41, 0x98 },  //uxga 0x68
	{ 0x42, 0x00 },
	{ 0x43, 0x14 },
//page10
	{ 0x03, 0x10 },  	
	{ 0x3f, 0x00 },
//page12	
	{ 0x03, 0x12 },
	{ 0x20, 0x0f },
	{ 0x21, 0x0f },				
	{ 0x90, 0x5d },
//page123	
	{ 0x03, 0x13 },  
	{ 0x80, 0xfd },		
	
	{ 0x03, 0x00 },	
	{ 0x10, 0x11 }, //select svga
	ENDMARKER,
};

static const struct regval_list hi253_vga_regs[] = {
	ENDMARKER,
};

//static const struct regval_list * const hi253_vga_regs = &hi253_sensor_yuv640X480;








/*
 * supported format list
 */

#define SETFOURCC(type) .name = (#type), .fourcc = (V4L2_PIX_FMT_ ## type)
static const struct soc_camera_data_format hi253_fmt_lists[] = {
	{
		SETFOURCC(YUYV),
		.depth      = 16,
		.colorspace = V4L2_COLORSPACE_JPEG,
	},
	{
		SETFOURCC(YVYU),
		.depth      = 16,
		.colorspace = V4L2_COLORSPACE_JPEG,
	},
	{
		SETFOURCC(UYVY),
		.depth      = 16,
		.colorspace = V4L2_COLORSPACE_JPEG,
	},
	{
		SETFOURCC(RGB555),
		.depth      = 16,
		.colorspace = V4L2_COLORSPACE_SRGB,
	},
	{
		SETFOURCC(RGB555X),
		.depth      = 16,
		.colorspace = V4L2_COLORSPACE_SRGB,
	},
	{
		SETFOURCC(RGB565),
		.depth      = 16,
		.colorspace = V4L2_COLORSPACE_SRGB,
	},
	{
		SETFOURCC(RGB565X),
		.depth      = 16,
		.colorspace = V4L2_COLORSPACE_SRGB,
	},
};

/*
 * color format list
 */
static const struct hi253_color_format hi253_cfmts[] = {
	{
		.format = &hi253_fmt_lists[0],
	},
	{
		.format = &hi253_fmt_lists[1],
	},
	{
		.format = &hi253_fmt_lists[2],
	},
	{
		.format = &hi253_fmt_lists[3],
	},
	{
		.format = &hi253_fmt_lists[4],
	},
	{
		.format = &hi253_fmt_lists[5],
	},
	{
		.format = &hi253_fmt_lists[6],
	},
};


/*
 * window size list
 */
 #define UXGA_WIDTH	1600
 #define UXGA_HEIGHT	1200
#define SVGA_WIDTH   800
#define SVGA_HEIGHT  600
#define VGA_WIDTH   640
#define VGA_HEIGHT  480
#define GP_WIDTH		352
#define GP_HEIGHT		288
#define SXGA_WIDTH  1280
#define SXGA_HEIGHT 960
#define MAX_WIDTH   1600
#define MAX_HEIGHT  1200

static const struct hi253_win_size hi253_win_uxga = {
	.name     = "UXGA",
	.width    = UXGA_WIDTH,
	.height   = UXGA_HEIGHT,
	.regs     = hi253_sensor_yuv1600X1200,
};

static const struct hi253_win_size hi253_win_sxga = {
	.name     = "SXGA",
	.width    = SXGA_WIDTH,
	.height   = SXGA_HEIGHT,
	.regs     = hi253_sensor_yuv1280X960,
};

static const struct hi253_win_size hi253_win_svga = {
	.name     = "SVGA",
	.width    = SVGA_WIDTH,
	.height   = SVGA_HEIGHT,
	.regs     = hi253_sensor_yuv800X600,
};

static const struct hi253_win_size hi253_win_vga = {
	.name     = "VGA",
	.width    = VGA_WIDTH,
	.height   = VGA_HEIGHT,
	.regs     = hi253_sensor_yuv640X480,
};

static const struct hi253_win_size hi253_win_3gp = {
	.name     = "3GP",
	.width    = GP_WIDTH,
	.height   = GP_HEIGHT,
	.regs     = hi253_sensor_yuv352X288,
};

static const struct v4l2_queryctrl hi253_controls[] = {
	{
		.id		= V4L2_CID_VFLIP,
		.type		= V4L2_CTRL_TYPE_BOOLEAN,
		.name		= "Flip Vertically",
		.minimum	= 0,
		.maximum	= 1,
		.step		= 1,
		.default_value	= 0,
	},
	{
		.id		= V4L2_CID_HFLIP,
		.type		= V4L2_CTRL_TYPE_BOOLEAN,
		.name		= "Flip Horizontally",
		.minimum	= 0,
		.maximum	= 1,
		.step		= 1,
		.default_value	= 0,
	},
	{
		.id		= V4L2_CID_BAND_STOP_FILTER,
		.type		= V4L2_CTRL_TYPE_INTEGER,
		.name		= "Band-stop filter",
		.minimum	= 0,
		.maximum	= 256,
		.step		= 1,
		.default_value	= 0,
	},
};
static int  hi253_mask_set(struct i2c_client *client,
					  u8  command,
					  u8  mask,
					  u8  set)
{
	s32 val = i2c_smbus_read_byte_data(client, command);
	if (val < 0)
		return val;

 	val &= ~mask;
	val |= set & mask;

	return i2c_smbus_write_byte_data(client, command, val);
}

static int hi253_write_array(struct i2c_client *client,
			      const struct regval_list *vals)
{
	while (vals->reg_num != 0xff) {
		int ret = i2c_smbus_write_byte_data(client,
						    vals->reg_num,
						    vals->value);
		if (ret < 0)
			return ret;
		vals++;
	}
	return 0;
}


/********************* MTK mt6253 ********************/

void hi253_sensor_setting_init(struct i2c_client *client)
{
	u32 iEcount;
	unsigned char temp = 0;

	SENDBG("entry %s\n", __func__);
	for(iEcount=0;(!((0xff==(hi253_sensor_yuv640X480[iEcount].reg_num))&&(0xff==(hi253_sensor_yuv640X480[iEcount].value))));iEcount++)
	{	
		i2c_smbus_write_byte_data(client, hi253_sensor_yuv640X480[iEcount].reg_num, hi253_sensor_yuv640X480[iEcount].value);
	}
	
	i2c_smbus_write_byte_data(client, 0x03, 0x00);
	temp = i2c_smbus_read_byte_data(client, 0x11);
	temp |= 0x03;
	i2c_smbus_write_byte_data(client, 0x03, 0x00);
	i2c_smbus_write_byte_data(client, 0x11, temp);
	SENDBG("leave %s\n", __func__);
	
}


/*
 * general function
 */

static struct hi253_priv *to_hi253(const struct i2c_client *client)
{
	return container_of(i2c_get_clientdata(client), struct hi253_priv, subdev);
}

static int hi253_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
{
	struct i2c_client *client = sd->priv;
	struct hi253_priv *priv = to_hi253(client);

	switch (ctrl->id) {
	case V4L2_CID_VFLIP:
//		ctrl->value = priv->flag_vflip;
		break;
	case V4L2_CID_HFLIP:
//		ctrl->value = priv->flag_hflip;
		break;
	case V4L2_CID_BAND_STOP_FILTER:
//		ctrl->value = priv->band_filter;
		break;
	}
	return 0;
}

static int hi253_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
{
	struct i2c_client *client = sd->priv;
	struct hi253_priv *priv = to_hi253(client);
	int ret = 0;
	u8 val;

	printk(KERN_INFO "Entry hi253_s_ctrl:\n");
	switch (ctrl->id) {
		case V4L2_CID_DO_WHITE_BALANCE:
			printk(KERN_INFO "V4L2_CID_DO_WHITE_BALANCE=0x%08x", V4L2_CID_DO_WHITE_BALANCE);
			printk(KERN_INFO "value = %d\n", ctrl->value);
			if (ctrl->value < 7) {
				hi253_write_array(client, &HI253_wb_tab[ctrl->value -1][0]);
			}
			break;
			
		case V4L2_CID_COLORFX:
			printk(KERN_INFO "V4L2_CID_COLORFX=0x%08x", V4L2_CID_COLORFX);
			printk(KERN_INFO "value = %d\n", ctrl->value);
			if (ctrl->value < 7) {
				hi253_write_array(client, &HI253_effect_tab[ctrl->value -1][0]);
			}

			break;
		default:
			break;
	}

	printk(KERN_INFO "Leave hi253_s_ctrl\n");

	return ret;
}


static int hi253_g_chip_ident(struct v4l2_subdev *sd,
			       struct v4l2_dbg_chip_ident *id)
{
	struct i2c_client *client = sd->priv;
	struct hi253_priv *priv = to_hi253(client);

	id->ident    = priv->model;
	id->revision = 0;

	return 0;
}

static const struct hi253_win_size *hi253_select_win(u32 width, u32 height)
{
	const struct hi253_win_size *win;

	SENDBG("entry %s\n", __func__);

	win = &hi253_win_vga;	
	/* default is UXVGA */
	if (width == 1600 && height == 1200) {
		win = &hi253_win_uxga;	
		SENDBG("mach %s: width = %d, height = %d\n", 
		win->name, win->width, win->height);
	}
	
	if (width == 1280 && height == 960) {
		SENDBG("mach %s: width = %d, height = %d\n", 
		win->name, win->width, win->height);		
		win = &hi253_win_sxga;	
	}
	if (width == 640 && height == 480) {
		win = &hi253_win_vga;
		SENDBG("mach %s: width = %d, height = %d\n", 
		win->name, win->width, win->height);		
	}	
	if (width == 800 && height == 600) {
		win = &hi253_win_sxga;	
		SENDBG("mach %s: width = %d, height = %d\n", 
		win->name, win->width, win->height);		
	}

	if (width == 352 && height == 288) {
		printk(KERN_DEBUG"width = %d && height = %d\n", width, height);
		win = &hi253_win_3gp;			
		SENDBG("mach %s: width = %d, height = %d\n", 
		win->name, win->width, win->height);		
	}

	SENDBG("leave %s\n", __func__);
	
	return win;
}

static int hi253_set_params(struct i2c_client *client,
			     u32 *width, u32 *height, u32 pixfmt)
{
	struct hi253_priv *priv = to_hi253(client);
	int ret = -EINVAL;
	int i;

	SENDBG("entry %s\n", __func__);
	
	/*
	 * select format for priv->fmt
	 */
	priv->fmt = NULL;
	for (i = 0; i < ARRAY_SIZE(hi253_cfmts); i++) {
		if (pixfmt == hi253_cfmts[i].format->fourcc) {
			priv->fmt = hi253_cfmts + i;
			break;
		}
	}
	if (!priv->fmt)
		goto hi253_set_fmt_error;
 
	/*
	 * select win for priv->win
	 */
	priv->win = hi253_select_win(*width, *height);
	
	/*
	 * set size format
	 */
	SENDBG("select %s\n", priv->win->name);
	 
	ret = hi253_write_array(client, priv->win->regs);

	if (ret < 0)
		goto hi253_set_fmt_error;

	*width = priv->win->width;
	*height = priv->win->height;

	SENDBG("leave %s succeedded!\n", __func__);
	return 0;

hi253_set_fmt_error:
	priv->win = NULL;
	priv->fmt = NULL;
	
	SENDBG("leave %s failed!\n", __func__);
	
	return ret;
}

/* first called by soc_camera_prove to initialize lcd->user_width... */
static int hi253_g_fmt(struct v4l2_subdev *sd, struct v4l2_format *f)
{
	struct i2c_client *client = sd->priv;
	struct hi253_priv *priv = to_hi253(client);
	struct v4l2_pix_format *pix = &f->fmt.pix;

	SENDBG("entry %s\n", __func__);

	if (!priv->win || !priv->fmt) {
//		SENDBG("select UXGA for first time\n");
		u32 width = GP_WIDTH; 
		u32 height = GP_HEIGHT;
		int ret = hi253_set_params(client, &width, &height,
					    V4L2_PIX_FMT_YUYV);
		if (ret < 0)
			return ret;
	}

	f->type			= V4L2_BUF_TYPE_VIDEO_CAPTURE;

	pix->width		= priv->win->width;
	pix->height		= priv->win->height;
	pix->pixelformat	= priv->fmt->format->fourcc;
	pix->colorspace		= priv->fmt->format->colorspace;
	pix->field		= V4L2_FIELD_NONE;

	SENDBG("leave %s\n", __func__);

	return 0;
}


static int hi253_try_fmt(struct v4l2_subdev *sd,
			  struct v4l2_format *f)
{
	struct v4l2_pix_format *pix = &f->fmt.pix;
	const struct hi253_win_size *win;

	SENDBG("entry %s\n", __func__);

	/*
	 * select suitable win
	 */
	win = hi253_select_win(pix->width, pix->height);

	pix->width  = win->width;
	pix->height = win->height;
	pix->field  = V4L2_FIELD_NONE;
	
	SENDBG("entry %s\n", __func__);

	return 0;
}

static int hi253_s_fmt(struct v4l2_subdev *sd, struct v4l2_format *f)
{
	struct i2c_client *client = sd->priv;
	struct v4l2_pix_format *pix = &f->fmt.pix;

	SENDBG("entry %s\n", __func__);

	return hi253_set_params(client, &pix->width, &pix->height,
				 pix->pixelformat);
}

static unsigned long hi253_query_bus_param(struct soc_camera_device *icd)
{
	struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
	struct hi253_priv *priv = i2c_get_clientdata(client);
	struct soc_camera_link *icl = to_soc_camera_link(icd);
	unsigned long flags = SOCAM_PCLK_SAMPLE_RISING | SOCAM_MASTER |
		SOCAM_VSYNC_ACTIVE_HIGH | SOCAM_HSYNC_ACTIVE_HIGH |
		SOCAM_DATA_ACTIVE_HIGH | priv->info->buswidth;

	SENDBG("entry %s\n", __func__);

	return soc_camera_apply_sensor_flags(icl, flags);
}

static int hi253_set_bus_param(struct soc_camera_device *icd,
				unsigned long		  flags)
{
	SENDBG("entry %s\n", __func__);

	return 0;
} 

static int hi253_cropcap(struct v4l2_subdev *sd, struct v4l2_cropcap *a)
{
	struct i2c_client *client = sd->priv;

	SENDBG("entry %s\n", __func__);

	a->bounds.left			= 0;
	a->bounds.top			= 0;
	a->bounds.width			= MAX_WIDTH;
	a->bounds.height		= MAX_HEIGHT;
	a->defrect.width		= VGA_WIDTH;
	a->defrect.height		= VGA_HEIGHT;
	a->type				= V4L2_BUF_TYPE_VIDEO_CAPTURE;
	a->pixelaspect.numerator	= 1;
	a->pixelaspect.denominator	= 1;

	/* fix me */
	hi253_write_array(client, HI253_YUV_640X480);
	hi253_mask_set(client, PWRCTL, SOFT_SLEEP_MODE, SOFT_SLEEP_ON);

	
	SENDBG("leave %s\n", __func__);
	
	return 0;
}

static int hi253_g_crop(struct v4l2_subdev *sd, struct v4l2_crop *a)
{
	struct i2c_client *client = sd->priv;
	struct hi253_priv *priv = to_hi253(client);

	SENDBG("entry %s\n", __func__);

	a->c.left	= 0;
	a->c.top	= 0;
	a->c.width	= priv->win->width;
	a->c.height	= priv->win->height;
	a->type		= V4L2_BUF_TYPE_VIDEO_CAPTURE;
	
	SENDBG("leave %s\n", __func__);

	return 1;
}



static int hi253_s_crop(struct v4l2_subdev *sd, struct v4l2_crop *a)
{
	struct i2c_client *client = sd->priv;
	struct hi253_priv *priv = to_hi253(client);
	struct hi253_win_size *win;

	SENDBG("leave %s\n", __func__);

	/* select suitable windows */
	win = hi253_select_win(a->c.width, a->c.height);

	/* set sensor register */
	hi253_write_array(client, priv->win->regs);	
	
	SENDBG("leave %s\n", __func__);
	
	return 0;
}

/*
 * soc_camera_ops function
 */

static int hi253_s_stream(struct v4l2_subdev *sd, int enable)
{
	struct i2c_client *client = sd->priv;
	struct hi253_priv *priv = to_hi253(client);
	unsigned char temp = 0;

	SENDBG("entry %s\n", __func__);

	if (!enable) {
		// sleep on
		hi253_mask_set(client, PWRCTL, SOFT_SLEEP_MODE, SOFT_SLEEP_ON);
		return 0;
	}
	
	// sleep on
//	hi253_mask_set(client, PWRCTL, SOFT_SLEEP_MODE, SOFT_SLEEP_ON);

	/* init the sensor with mt6253 setting */
//	hi253_sensor_setting_init(client);

//	SENDBG("select %s\n", priv->win->name);
//	hi253_write_array(client, 	priv->win->regs);
//	hi253_write_array(client, HI253_YUV_640X480);

	// sleep off
	hi253_mask_set(client, PWRCTL, SOFT_SLEEP_MODE, SOFT_SLEEP_OFF);

	SENDBG("leave %s\n", __func__);
	
	return 0;
}

static int hi253_video_probe(struct soc_camera_device *icd,
			      struct i2c_client *client)
{
	struct hi253_priv *priv = to_hi253(client);
	u8				pid;
	const char         *devname;

	SENDBG("entry %s\n", __func__);

	/*
	 * We must have a parent by now. And it cannot be a wrong one.
	 * So this entire test is completely redundant.
	 */
	if (!icd->dev.parent ||
	    to_soc_camera_host(icd->dev.parent)->nr != icd->iface)
		return -ENODEV;

	/*
	 * hi253 only use 8 or 10 bit bus width
	 */
	if (SOCAM_DATAWIDTH_10 != priv->info->buswidth &&
	    SOCAM_DATAWIDTH_8  != priv->info->buswidth) {
		dev_err(&client->dev, "bus width error\n");
		return -ENODEV;
	}

	icd->formats     = hi253_fmt_lists;
	icd->num_formats = ARRAY_SIZE(hi253_fmt_lists);

	/*
	 * check and show product ID and manufacturer ID
	 */
	pid = i2c_smbus_read_byte_data(client, DEVID);

	if (pid != HI253_PID) {
		dev_err(&client->dev,  "Product ID error %x\n", pid);
		return -ENODEV;	
	}
	
	devname 	= "hi253";
	priv->model = pid;

	dev_info(&client->dev,
		 "Probing %s Product ID %0x\n",
		 devname, pid);

	SENDBG("leave %s\n", __func__);

	return 0;
}

static struct soc_camera_ops hi253_ops = {
	.set_bus_param		= hi253_set_bus_param,
	.query_bus_param	= hi253_query_bus_param,
	.controls		= hi253_controls,
	.num_controls		= ARRAY_SIZE(hi253_controls),
};

static struct v4l2_subdev_core_ops hi253_subdev_core_ops = {
	.g_ctrl		= hi253_g_ctrl,
	.s_ctrl		= hi253_s_ctrl,
	.g_chip_ident	= hi253_g_chip_ident,
};

static struct v4l2_subdev_video_ops hi253_subdev_video_ops = {
	.s_stream	= hi253_s_stream,
	.g_fmt		= hi253_g_fmt,
	.s_fmt		= hi253_s_fmt,
	.try_fmt	= hi253_try_fmt,
	.cropcap	= hi253_cropcap,
	.g_crop		= hi253_g_crop,
	.s_crop		= hi253_s_crop,
};

static struct v4l2_subdev_ops hi253_subdev_ops = {
	.core	= &hi253_subdev_core_ops,
	.video	= &hi253_subdev_video_ops,
};

/*
 * i2c_driver function
 */

static int hi253_probe(struct i2c_client *client,
			const struct i2c_device_id *did)
{
	struct hi253_priv        *priv;
	struct hi253_camera_info *info;
	struct soc_camera_device  *icd = client->dev.platform_data;
	struct i2c_adapter        *adapter = to_i2c_adapter(client->dev.parent);
	struct soc_camera_link    *icl;
	int                        ret;

	SENDBG("entry %s\n", __func__);

	if (!icd) {
		dev_err(&client->dev, "HI253: missing soc-camera data!\n");
		return -EINVAL;
	}

	icl = to_soc_camera_link(icd);
	if (!icl)
		return -EINVAL;
	
	info = container_of(icl, struct hi253_camera_info, link);

	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {
		dev_err(&adapter->dev,
			"I2C-Adapter doesn't support "
			"I2C_FUNC_SMBUS_BYTE_DATA\n");
		return -EIO;
	}

	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
	if (!priv) {
		return -ENOMEM;
	}	

	priv->info = info;

	v4l2_i2c_subdev_init(&priv->subdev, client, &hi253_subdev_ops);

	icd->ops		= &hi253_ops;

	ret = hi253_video_probe(icd, client);
	
	if (ret) {
		icd->ops = NULL;
		i2c_set_clientdata(client, NULL);
		kfree(priv);
	}

	SENDBG("leave %s\n", __func__);

	return ret;
}

static int hi253_remove(struct i2c_client *client)
{
	struct hi253_priv *priv = to_hi253(client);
	struct soc_camera_device *icd = client->dev.platform_data;

	icd->ops = NULL;
	i2c_set_clientdata(client, NULL);
	kfree(priv);
	return 0;
}

static const struct i2c_device_id hi253_id[] = {
	{ "hi253", 0 },
	{ }
};
MODULE_DEVICE_TABLE(i2c, hi253);

static struct i2c_driver hi253_i2c_driver = {
	.driver = {
		.name = "hi253",
	},
	.probe    = hi253_probe,
	.remove   = hi253_remove,
	.id_table = hi253_id,
};

/*
 * module function
 */

static int __init hi253_module_init(void)
{
	
	SENDBG("entry %s\n", __func__);

	return i2c_add_driver(&hi253_i2c_driver);
}

static void __exit hi253_module_exit(void)
{
	SENDBG("entry %s\n", __func__);

	i2c_del_driver(&hi253_i2c_driver);
}

module_init(hi253_module_init);
module_exit(hi253_module_exit);

MODULE_DESCRIPTION("SoC Camera driver for hi253");
MODULE_AUTHOR("wu_daochao@anyka.oa");
MODULE_LICENSE("GPL v2");
